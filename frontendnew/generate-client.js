// This script reads an OpenAPI specification file and generates
// a React Query client with hooks for each endpoint.

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Resolve file paths using the current module's URL, which is the
// idiomatic way to handle paths in ES module scope.
const currentDir = path.dirname(fileURLToPath(import.meta.url));
const openApiSpecPath = path.resolve(currentDir, '../api-specs/merged.json');
const generatedHooksPath = path.resolve(currentDir, 'src/hooks/useApis.jsx');

// HTTP methods to look for in the OpenAPI spec
const httpMethods = ['get', 'post', 'put', 'delete', 'patch'];

function toCamelCase(str) {
  return str.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
}

function toPascalCase(str) {
  return str.charAt(0).toUpperCase() + toCamelCase(str.slice(1));
}

// Helper function to extract a JSDoc type from a schema object, handling $ref
function getSchemaType(schema) {
  if (!schema) {
    return 'any';
  }

  if (schema.$ref) {
    // Extract the component name from the $ref (e.g., User from #/components/schemas/User)
    return schema.$ref.split('/').pop();
  }

  if (schema.type === 'array' && schema.items) {
    const itemType = getSchemaType(schema.items);
    return `${itemType}[]`;
  }

  // Fallback for simple types or inline objects
  return schema.type || 'object';
}

function generateJsDocForSchema(name, schema) {
  let jsDoc = `/**\n * @typedef {object} ${name}\n`;
  if (schema.properties) {
    for (const propName in schema.properties) {
      const prop = schema.properties[propName];
      const propType = getSchemaType(prop);
      const description = prop.description ? ` - ${prop.description}` : '';
      jsDoc += ` * @property {${propType}} ${propName}${description}\n`;
    }
  }
  jsDoc += ` */\n`;
  return jsDoc;
}

function generateClientCode(spec) {
  let hooksCode = `
// This file is auto-generated by generateApiHooks.js. Do not edit manually.
// To regenerate, run 'npm run gen:api:client' or 'npm run dev'.
import { useQuery, useMutation } from '@tanstack/react-query';

// --- API Client Configuration ---
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'https://zettanix.in';

/**
 * A generic API client that handles different content types.
 * @param {string} method HTTP method (e.g., 'get', 'post')
 * @param {string} path API endpoint path
 * @param {any} data Request body data
 * @param {string} contentType The Content-Type header value
 */
async function apiClient(method, path, data = null, contentType = 'application/json') {
  const url = \`\${API_BASE_URL}\${path}\`;
  const options = {
    method: method.toUpperCase(),
  };

  // Add authorization header if token exists
  const token = localStorage.getItem('accessToken');
  if (token) {
    options.headers = {
      'Authorization': \`Bearer \${token}\`,
    };
    console.log('API call with token:', token.substring(0, 10) + '...');
  } else {
    console.log('No token found for API call to:', path);
  }

  if (data) {
    if (contentType === 'multipart/form-data') {
      options.body = data; // Assumes data is already a FormData object
    } else {
      options.headers = {
        ...options.headers,
        'Content-Type': contentType,
      };
      options.body = JSON.stringify(data);
    }
  }

  const response = await fetch(url, options);

  if (!response.ok) {
    const error = new Error(\`API request failed with status \${response.status}\`);
    try {
      error.response = await response.json();
    } catch (e) {
      error.response = await response.text();
    }
    throw error;
  }

  if (response.headers.get('content-type')?.includes('application/json')) {
    return response.json();
  }
  
  return response.text();
}

// --- Generated Models & Types ---
`;

  // Generate JSDoc typedefs for all schemas in the spec
  if (spec.components && spec.components.schemas) {
    for (const schemaName in spec.components.schemas) {
      const schema = spec.components.schemas[schemaName];
      hooksCode += generateJsDocForSchema(schemaName, schema);
    }
  }

  hooksCode += `
// --- Generated React Query Hooks ---
`;

  // Iterate over each path in the spec
  for (const pathKey in spec.paths) {
    const pathItem = spec.paths[pathKey];

    // Iterate over each HTTP method for the current path
    for (const method of httpMethods) {
      if (pathItem[method]) {
        const operation = pathItem[method];
        const operationId = operation.operationId || `${method}${toPascalCase(pathKey.replace(/[\/\{\}]/g, ''))}`;
        const functionName = `${toCamelCase(operationId)}`;

        // Get request body and response schemas
        let requestBodySchema = null;
        let requestContentType = null;
        if (operation.requestBody?.content) {
          const contentTypes = Object.keys(operation.requestBody.content);
          if (contentTypes.length > 0) {
            requestContentType = contentTypes[0];
            requestBodySchema = operation.requestBody.content[requestContentType].schema;
          }
        }

        let responseSchema = null;
        let responseContentType = null;
        for (const statusCode in operation.responses) {
          const response = operation.responses[statusCode];
          if (response.content) {
            const contentTypes = Object.keys(response.content);
            if (contentTypes.length > 0) {
              responseContentType = contentTypes[0];
              responseSchema = response.content[responseContentType].schema;
              break;
            }
          }
        }
        
        const requestType = requestBodySchema ? getSchemaType(requestBodySchema) : 'void';
        const responseType = responseSchema ? getSchemaType(responseSchema) : 'any';

        // Check if it's a query or a mutation
        const isQuery = method === 'get';

        if (isQuery) {
          // Check if this endpoint has path parameters that need substitution
          const hasPathParams = pathKey.includes('{') && pathKey.includes('}');
          const paramName = pathKey.includes('{resume_id}') ? 'resume_id' : 
                           pathKey.includes('{job_id}') ? 'job_id' : 
                           pathKey.includes('{company_id}') ? 'company_id' : null;
          
          if (hasPathParams && paramName) {
            // Generate a useQuery hook with parameter substitution
            hooksCode += `
/**
 * @description Hook for ${pathKey} [${method.toUpperCase()}]
 * @returns {import('@tanstack/react-query').QueryResult<${responseType}>}
 */
export const ${functionName} = (options) => {
  const ${paramName} = options?.${paramName};
  const queryKey = ['${operationId}', ${paramName}];
  return useQuery({
    queryKey,
    queryFn: () => apiClient('${method}', \`${pathKey.replace(`{${paramName}}`, `\${${paramName}}`)}\`),
    enabled: !!${paramName},
    ...options,
  });
};
`;
          } else {
            // Generate a regular useQuery hook
            hooksCode += `
/**
 * @description Hook for ${pathKey} [${method.toUpperCase()}]
 * @returns {import('@tanstack/react-query').QueryResult<${responseType}>}
 */
export const ${functionName} = (options) => {
  const queryKey = ['${operationId}'];
  return useQuery({
    queryKey,
    queryFn: () => apiClient('${method}', '${pathKey}'),
    ...options,
  });
};
`;
          }
        } else {
          // Check if this mutation has path parameters that need substitution
          const hasPathParams = pathKey.includes('{') && pathKey.includes('}');
          const paramName = pathKey.includes('{resume_id}') ? 'resume_id' : 
                           pathKey.includes('{job_id}') ? 'job_id' : 
                           pathKey.includes('{company_id}') ? 'company_id' : null;
          
          const contentTypeParam = requestContentType ? `, '${requestContentType}'` : '';
          
          if (hasPathParams && paramName) {
            // Generate a useMutation hook with parameter substitution
            hooksCode += `
/**
 * @description Hook for ${pathKey} [${method.toUpperCase()}]
 * @param {${requestType}} data The request body based on the OpenAPI specification.
 * @returns {import('@tanstack/react-query').MutationResult<${responseType}, unknown, ${requestType}>}
 */
export const ${functionName} = (options) => {
  return useMutation({
    mutationFn: ({ ${paramName}, ...data }) => apiClient('${method}', \`${pathKey.replace(`{${paramName}}`, `\${${paramName}}`)}\`, data${contentTypeParam}),
    ...options,
  });
};
`;
          } else {
            // Generate a regular useMutation hook
            hooksCode += `
/**
 * @description Hook for ${pathKey} [${method.toUpperCase()}]
 * @param {${requestType}} data The request body based on the OpenAPI specification.
 * @returns {import('@tanstack/react-query').MutationResult<${responseType}, unknown, ${requestType}>}
 */
export const ${functionName} = (options) => {
  return useMutation({
    mutationFn: (data) => apiClient('${method}', '${pathKey}', data${contentTypeParam}),
    ...options,
  });
};
`;
          }
        }
      }
    }
  }

  return hooksCode;
}

function generateHooks() {
  try {
    console.log('--- Generating React Query hooks from OpenAPI spec ---');
    const specContent = fs.readFileSync(openApiSpecPath, 'utf8');
    const spec = JSON.parse(specContent);
    const code = generateClientCode(spec);
    fs.writeFileSync(generatedHooksPath, code);
    console.log('--- Successfully generated hooks.jsx ---');
  } catch (error) {
    console.error('Error generating hooks:', error);
    console.log('--- Using existing useApis.jsx file ---');
    // Don't fail the build if the OpenAPI spec is missing
    // The existing useApis.jsx file will be used instead
  }
}

// If this script is run directly, generate the hooks.
if (process.argv[1] === path.resolve(process.argv[1])) {
  generateHooks();
}

// Export the function for use in the Vite plugin.
export { generateHooks };